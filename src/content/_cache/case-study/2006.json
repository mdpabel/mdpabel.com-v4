{
  "id": 2006,
  "slug": "how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m",
  "date": "2026-01-30T22:58:10",
  "modified": "2026-01-30T16:58:10",
  "title": "How We Reduced Headless WordPress Build Times by 90% (29m to 3m)",
  "content": "<div class=\"case-study-container\">\n<h3>Executive Summary</h3>\n<p>This case study details the optimization of a high-performance static site (SSG) built with <strong>Astro</strong> and <strong>Headless WordPress</strong>. Facing build times exceeding 29 minutes due to an &#8220;N+1&#8221; data-fetching bottleneck, we engineered a custom caching layer that reduced external API requests by over 99%. The result was a stable, lightning-fast build process completing in just 3 minutes—a <strong>9.5x improvement</strong>.</p>\n<hr />\n<h3>1. The Challenge: The &#8220;N+1&#8221; Bottleneck</h3>\n<p>Our architecture relies on Astro for the frontend and WordPress as a headless CMS. While this offers great content management, the standard method of fetching data during a Static Site Generation (SSG) build introduced a critical flaw.</p>\n<p>For every single page generated, the build process was making unique network requests:</p>\n<ul>\n<li><strong>Blog Post Pages:</strong> 1 request for the post content + 1 request for related posts.</li>\n<li><strong>Case Studies &amp; Guides:</strong> Similar redundant fetching patterns.</li>\n<li><strong>Pagination:</strong> Repeatedly hitting the API for page counts and slicing.</li>\n</ul>\n<h4>The Math of Inefficiency:</h4>\n<p>With a library of ~100 posts across various types, our build server was firing <strong>hundreds of separate HTTP requests</strong> to the WordPress backend.</p>\n<ul>\n<li><strong>Consequence 1:</strong> The WordPress server (on shared hosting) would frequently time out or throttle connections (&#8220;ECONNRESET&#8221;).</li>\n<li><strong>Consequence 2:</strong> Build times ballooned to <strong>29 minutes and 7 seconds</strong>, making rapid deployment impossible.</li>\n</ul>\n<p><img loading=\"lazy\" decoding=\"async\" class=\" wp-image-2007 aligncenter\" src=\"https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-2-300x128.png\" alt=\"\" width=\"683\" height=\"291\" srcset=\"https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-2-300x128.png 300w, https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-2-1024x438.png 1024w, https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-2-1536x657.png 1536w, https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-2.png 1919w\" sizes=\"auto, (max-width: 683px) 100vw, 683px\" /></p>\n<hr />\n<h3>2. The Solution: &#8220;Fetch Once, Reuse Everywhere&#8221;</h3>\n<p>We engineered a custom data layer in TypeScript (<code>wordpress.ts</code>) to implement a <strong>Singleton Promise Cache</strong>. The core philosophy was simple: <strong>Never ask the API for the same data twice.</strong></p>\n<h4>A. Smart Promise Caching</h4>\n<p>Instead of caching the <em>result</em> (the JSON data), we cached the <em>active Promise</em> (the network request itself).</p>\n<ul>\n<li><strong>Scenario:</strong> If 50 pages start building simultaneously and ask for &#8220;All Blog Posts,&#8221; they all check the cache.</li>\n<li><strong>Outcome:</strong> The first page initiates the request. The other 49 pages see the pending request and &#8220;hook onto&#8221; it.</li>\n<li><strong>Result:</strong> <strong>1 network request</strong> serves 50 pages instantly.</li>\n</ul>\n<h4>B. Type Isolation Strategy</h4>\n<p>To prevent data collisions between different content types (e.g., showing a &#8220;Case Study&#8221; on a &#8220;Blog&#8221; list), we implemented a <code>Map</code>-based cache key system:</p>\n<ul>\n<li><code>'all-posts'</code> → Stores Blog Posts</li>\n<li><code>'all-case-study'</code> → Stores Case Studies</li>\n<li><code>'all-guide'</code> → Stores Guides</li>\n</ul>\n<h4>C. Zero-Latency Pagination &amp; Relations</h4>\n<p>We moved logic from the <em>server</em> to the <em>build process</em>:</p>\n<ul>\n<li><strong>Pagination:</strong> Instead of asking WordPress for &#8220;Page 2,&#8221; we fetch <em>everything</em> once and slice the array in memory using JavaScript.</li>\n<li><strong>Related Posts:</strong> Instead of an expensive API query for every single post, we filter the in-memory array to find related content. Latency dropped from ~1.5s per post to <strong>0ms</strong>.</li>\n</ul>\n<h4>D. Stability Engineering</h4>\n<p>To handle the flaky shared hosting environment, we added an exponential backoff retry mechanism. If a request failed, the system would wait 1 second and try again (up to 3 times) before failing the build.</p>\n<hr />\n<h3>3. Technical Implementation</h3>\n<p>Here is the core logic that powered the transformation.</p>\n<p><strong>The Singleton Fetcher (<code>src/lib/wordpress.ts</code>):</strong></p>\n<pre><code class=\"language-typescript\">class WordPressAPI {\r\n  // A Map to store active promises for different content types\r\n  private _requestCache = new Map&lt;string, Promise&lt;WordPressPost[]&gt;&gt;();\r\n\r\n  async getAllPosts(options: PostsQueryOptions = {}) {\r\n    const type = options.postType || 'posts';\r\n    const cacheKey = `all-${type}`;\r\n\r\n    // 1. Check Memory: If a fetch is running or done, return that Promise immediately.\r\n    if (this._requestCache.has(cacheKey)) {\r\n      return this._requestCache.get(cacheKey);\r\n    }\r\n\r\n    // 2. Fetch Network: Start the single request chain\r\n    const requestPromise = (async () =&gt; {\r\n      // ... complex chunking logic to fetch 50 items at a time ...\r\n      return allData;\r\n    })();\r\n\r\n    // 3. Save Promise: Store it so other pages can reuse it\r\n    this._requestCache.set(cacheKey, requestPromise);\r\n    return requestPromise;\r\n  }\r\n}</code></pre>\n<hr />\n<h3>4. The Results</h3>\n<p>The impact of this optimization was immediate and drastic.</p>\n<figure class=\"wp-block-table\">\n<table>\n<thead>\n<tr>\n<th>Metric</th>\n<th>Before Optimization</th>\n<th>After Optimization</th>\n<th>Improvement</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Total Build Time</strong></td>\n<td>29 min 07 sec</td>\n<td>3 min 06 sec</td>\n<td><strong>~9.5x Faster</strong></td>\n</tr>\n<tr>\n<td><strong>API Requests</strong></td>\n<td>1,000+ (Est.)</td>\n<td>~4 (1 per type)</td>\n<td><strong>99% Reduction</strong></td>\n</tr>\n<tr>\n<td><strong>Stability</strong></td>\n<td>Frequent Timeouts</td>\n<td>100% Success</td>\n<td><strong>Reliable</strong></td>\n</tr>\n<tr>\n<td><strong>Cost</strong></td>\n<td>High Server Load</td>\n<td>Minimal Load</td>\n<td><strong>Efficient</strong></td>\n</tr>\n</tbody>\n</table>\n</figure>\n<h4>Visual Proof:</h4>\n<p><img loading=\"lazy\" decoding=\"async\" class=\" wp-image-2008 aligncenter\" src=\"https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-1-300x129.png\" alt=\"\" width=\"689\" height=\"296\" srcset=\"https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-1-300x129.png 300w, https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-1-1024x439.png 1024w, https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-1-768x329.png 768w, https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-1-1536x659.png 1536w, https://cms.mdpabel.com/wp-content/uploads/2026/01/cf-1.png 1907w\" sizes=\"auto, (max-width: 689px) 100vw, 689px\" /></p>\n<p><strong>Before:</strong> Long, stalled builds waiting on network I/O.</p>\n<p><strong>After:</strong> Rapid completion with logs confirming cache hits:</p>\n<blockquote class=\"wp-block-quote\"><p><code>⚡ [Cache Hit] Reuse existing promise for 'all-malware-log'</code></p></blockquote>\n<hr />\n<h3>5. Key Takeaways</h3>\n<ol>\n<li><strong>Don&#8217;t rely on APIs for SSG logic:</strong> Move operations like sorting, filtering, and pagination into your build process memory whenever possible.</li>\n<li><strong>Cache the Promise, not just the Data:</strong> This solves the &#8220;Race Condition&#8221; where parallel pages trigger duplicate requests before the first one finishes.</li>\n<li><strong>Optimize for the Weakest Link:</strong> By adding chunking and retry logic, we made the build process resilient even against slow, shared hosting environments.</li>\n</ol>\n<p><em>This architecture is now the standard for all our future high-performance Astro projects.</em></p>\n</div>\n",
  "excerpt": "",
  "link": "https://cms.mdpabel.com/case-study/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/",
  "yoastHead": "<link rel=\"canonical\" href=\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\" />\n<!-- This site is optimized with the Yoast SEO Premium plugin v25.9 (Yoast SEO v26.8) - https://yoast.com/product/yoast-seo-premium-wordpress/ -->\n<title>How We Reduced Headless WordPress Build Times by 90% (29m to 3m) - MD Pabel</title>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" />\n<meta property=\"og:locale\" content=\"en_US\" />\n<meta property=\"og:type\" content=\"article\" />\n<meta property=\"og:title\" content=\"How We Reduced Headless WordPress Build Times by 90% (29m to 3m)\" />\n<meta property=\"og:description\" content=\"Executive Summary This case study details the optimization of a high-performance static site (SSG) built with Astro and Headless WordPress. Facing build times exceeding 29 minutes due to an &#8220;N+1&#8221; data-fetching bottleneck, we engineered a custom caching layer that reduced external API requests by over 99%. The result was a stable, lightning-fast build process completing [&hellip;]\" />\n<meta property=\"og:url\" content=\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\" />\n<meta property=\"og:site_name\" content=\"MD Pabel\" />\n<meta property=\"og:image\" content=\"https://cms.mdpabel.com/wp-content/uploads/2026/01/headless-opt.png?wsr\" />\n\t<meta property=\"og:image:width\" content=\"942\" />\n\t<meta property=\"og:image:height\" content=\"514\" />\n\t<meta property=\"og:image:type\" content=\"image/png\" />\n<meta name=\"twitter:card\" content=\"summary_large_image\" />\n<meta name=\"twitter:label1\" content=\"Est. reading time\" />\n\t<meta name=\"twitter:data1\" content=\"4 minutes\" />\n<script type=\"application/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https://schema.org\",\"@graph\":[{\"@type\":\"TechArticle\",\"@id\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\",\"isPartOf\":{\"@id\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\"},\"author\":{\"name\":\"MD Pabel\",\"@id\":\"https://www.mdpabel.com/#/schema/person/73e3797b5dc8d6434e9e35e1708bb0c4\"},\"headline\":\"How We Reduced Headless WordPress Build Times by 90% (29m to 3m)\",\"datePublished\":\"2026-01-30T16:58:10+00:00\",\"mainEntityOfPage\":{\"@id\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\"},\"wordCount\":599,\"commentCount\":0,\"image\":{\"@id\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\"},\"thumbnailUrl\":\"https://cms.mdpabel.com/wp-content/uploads/2026/01/headless-opt.png?wsr\",\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"CommentAction\",\"name\":\"Comment\",\"target\":[\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\"]}]},{\"@type\":\"WebPage\",\"@id\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\",\"url\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\",\"name\":\"How We Reduced Headless WordPress Build Times by 90% (29m to 3m) - MD Pabel\",\"isPartOf\":{\"@id\":\"https://www.mdpabel.com/#website\"},\"primaryImageOfPage\":{\"@id\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\"},\"image\":{\"@id\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\"},\"thumbnailUrl\":\"https://cms.mdpabel.com/wp-content/uploads/2026/01/headless-opt.png?wsr\",\"datePublished\":\"2026-01-30T16:58:10+00:00\",\"breadcrumb\":{\"@id\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\"]}]},{\"@type\":\"ImageObject\",\"inLanguage\":\"en-US\",\"@id\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\",\"url\":\"https://cms.mdpabel.com/wp-content/uploads/2026/01/headless-opt.png?wsr\",\"contentUrl\":\"https://cms.mdpabel.com/wp-content/uploads/2026/01/headless-opt.png?wsr\",\"width\":942,\"height\":514},{\"@type\":\"BreadcrumbList\",\"@id\":\"https://www.mdpabel.com/case-studies/how-we-reduced-headless-wordpress-build-times-by-90-29m-to-3m/\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https://www.mdpabel.com/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"How We Reduced Headless WordPress Build Times by 90% (29m to 3m)\"}]},{\"@type\":\"WebSite\",\"@id\":\"https://www.mdpabel.com/#website\",\"url\":\"https://www.mdpabel.com/\",\"name\":\"MD Pabel\",\"description\":\"Full Stack Developer, Malware Removal &amp; Security Specialist\",\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https://www.mdpabel.com/blog/?s={search_term_string}\"},\"query-input\":{\"@type\":\"PropertyValueSpecification\",\"valueRequired\":true,\"valueName\":\"search_term_string\"}}],\"inLanguage\":\"en-US\"}]}</script>\n<!-- / Yoast SEO Premium plugin. -->",
  "featuredImage": {
    "url": "https://cms.mdpabel.com/wp-content/uploads/2026/01/headless-opt.png",
    "alt": ""
  },
  "categories": [],
  "acf": {
    "problem_statement": "",
    "Impact_Metrics": "",
    "key_issues": "",
    "solution_overview": "",
    "key_results": ""
  }
}